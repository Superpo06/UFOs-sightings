<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Convertisseur CSV vers GeoJSON (Grands fichiers)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #2196F3;
            margin-bottom: 20px;
        }
        
        .warning-box {
            background: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ffc107;
            margin-bottom: 20px;
        }
        
        .progress-container {
            background: #f5f5f5;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
            display: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
        
        .progress-text {
            font-size: 14px;
            color: #666;
            text-align: center;
        }
        
        textarea {
            width: 100%;
            height: 150px;
            font-family: monospace;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            resize: vertical;
        }
        
        button {
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.3s;
        }
        
        button:hover:not(:disabled) {
            background: #45a049;
        }
        
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        .result {
            margin-top: 20px;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 5px;
            border: 1px solid #ddd;
            display: none;
        }
        
        .stats {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        
        .error {
            color: #d32f2f;
            background: #ffebee;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ffcdd2;
            margin: 10px 0;
            display: none;
        }
        
        .success {
            color: #388e3c;
            background: #e8f5e8;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #c8e6c9;
            margin: 10px 0;
        }
        
        .chunk-info {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-top: 10px;
        }
        
        .file-size {
            font-size: 14px;
            color: #666;
            margin: 5px 0;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üìä Convertisseur CSV ‚Üí GeoJSON pour grands fichiers</h1>

        <div class="info-box">
            <h3>‚ö†Ô∏è Fichier volumineux d√©tect√© (17+ Mo)</h3>
            <p>Ce convertisseur utilise un traitement par morceaux pour √©viter de bloquer votre navigateur.</p>
            <p><strong>Conseil :</strong> Pour de meilleures performances, fermez les autres onglets du navigateur.</p>
        </div>

        <div class="warning-box">
            <h4>üìã Format CSV requis :</h4>
            <ul>
                <li>S√©parateur : point-virgule (;)</li>
                <li>Encodage : UTF-8 recommand√©</li>
                <li>Structure : Minimum 16 colonnes</li>
                <li>Coordonn√©es : colonnes 12 (lat) et 13 (lon)</li>
            </ul>
        </div>

        <div>
            <h3>üìÅ S√©lectionnez votre fichier CSV</h3>
            <input type="file" id="csvFile" accept=".csv,.txt">
            <div id="fileInfo" class="file-size"></div>
        </div>

        <div>
            <h3>‚öôÔ∏è Options de conversion</h3>
            <label>
                <input type="checkbox" id="skipInvalid" checked>
                Ignorer les lignes invalides
            </label>
            <br>
            <label>
                <input type="checkbox" id="validateCoords" checked>
                Valider les coordonn√©es
            </label>
            <br>
            <label>
                Taille des morceaux (lignes) :
                <input type="number" id="chunkSize" value="10000" min="1000" max="50000" style="width: 100px;">
            </label>
        </div>

        <button id="convertBtn" onclick="startConversion()">üöÄ D√©marrer la conversion</button>

        <div class="progress-container" id="progressContainer">
            <h3>üîÑ Conversion en cours...</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text">
                <span id="progressText">0%</span>
                <br>
                <span id="processedText">0 lignes trait√©es</span>
            </div>
            <div class="chunk-info" id="chunkInfo"></div>
        </div>

        <div class="error" id="error"></div>

        <div class="result" id="result">
            <h3>‚úÖ Conversion termin√©e !</h3>
            <div id="status"></div>

            <div class="stats" id="stats"></div>

            <div>
                <button class="download-btn" onclick="downloadGeoJSON()" style="background: #2196F3;">üì• T√©l√©charger GeoJSON</button>
                <button onclick="showPreview()" style="background: #6c757d;">üëÅÔ∏è Aper√ßu des donn√©es</button>
                <button onclick="resetConverter()" style="background: #dc3545;">üîÑ Nouvelle conversion</button>
            </div>

            <div id="preview" style="display: none; margin-top: 20px;">
                <h4>Aper√ßu des premi√®res features :</h4>
                <pre id="previewContent" style="background: white; padding: 10px; border-radius: 4px; max-height: 300px; overflow-y: auto; font-size: 12px;"></pre>
            </div>
        </div>
    </div>

    <script>
        let currentGeoJSON = null;
        let conversionStats = null;
        let isConverting = false;
        let fileContent = '';
        let totalLines = 0;
        let countryNameToCode = {};
        let codeToName = {};

        // √âl√©ments DOM
        const elements = {
            csvFile: document.getElementById('csvFile'),
            convertBtn: document.getElementById('convertBtn'),
            progressContainer: document.getElementById('progressContainer'),
            progressFill: document.getElementById('progressFill'),
            progressText: document.getElementById('progressText'),
            processedText: document.getElementById('processedText'),
            chunkInfo: document.getElementById('chunkInfo'),
            error: document.getElementById('error'),
            result: document.getElementById('result'),
            status: document.getElementById('status'),
            stats: document.getElementById('stats'),
            fileInfo: document.getElementById('fileInfo'),
            preview: document.getElementById('preview'),
            previewContent: document.getElementById('previewContent')
        };

        async function loadCountryMapping() {
            let response = await fetch("data/country_name_mapping.csv");
            let text = await response.text();
            let lines = text.trim().split("\n").slice(1);

            for (let line of lines) {
                let [name, code] = line.split(",");
                countryNameToCode[name] = code;
                codeToName[code] = name;
            }
        }

        // Afficher une erreur
        function showError(message) {
            elements.error.textContent = message;
            elements.error.style.display = 'block';
            console.error('Erreur:', message);
        }

        // Masquer une erreur
        function hideError() {
            elements.error.style.display = 'none';
        }

        // Mettre √† jour la progression
        function updateProgress(percentage, processed, total) {
            const percent = Math.min(100, Math.max(0, percentage));
            elements.progressFill.style.width = percent + '%';
            elements.progressText.textContent = percent.toFixed(1) + '%';
            elements.processedText.textContent = `${processed.toLocaleString()} / ${total.toLocaleString()} lignes`;
        }

        // Parser une ligne CSV avec gestion des guillemets
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        // Double guillemet √† l'int√©rieur d'un champ
                        current += '"';
                        i++; // Saute le prochain guillemet
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ';' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }

            result.push(current);
            return result;
        }

        // Traiter un morceau de lignes
        function processChunk(lines, startIndex, chunkSize, options) {
            const features = [];
            const errors = [];
            let processed = 0;

            const endIndex = Math.min(startIndex + chunkSize, lines.length);

            for (let i = startIndex; i < endIndex; i++) {
                processed++;
                const line = lines[i].trim();

                if (!line) continue;

                try {
                    const cols = parseCSVLine(line);

                    // V√©rifier le nombre de colonnes
                    if (cols.length < 16 && options.skipInvalid) {
                        errors.push(`Ligne ${i + 1}: Format invalide (${cols.length} colonnes)`);
                        continue;
                    }

                    // Extraire et valider les coordonn√©es
                    const latStr = cols[11] || '';
                    const lonStr = cols[12] || '';
                    const lat = parseFloat(latStr.replace(',', '.'));
                    const lon = parseFloat(lonStr.replace(',', '.'));

                    if (options.validateCoords) {
                        if (isNaN(lat) || isNaN(lon)) {
                            errors.push(`Ligne ${i + 1}: Coordonn√©es invalides`);
                            continue;
                        }

                        if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                            errors.push(`Ligne ${i + 1}: Coordonn√©es hors limites`);
                            continue;
                        }
                    }

                    // Extraire l'ann√©e
                    let year = parseInt(cols[3]);
                    if (isNaN(year)) {
                        year = 0;
                    }
                    loadCountryMapping();
                    // Cr√©er la feature
                    features.push({
                        type: "Feature",
                        geometry: {
                            type: "Point",
                            coordinates: [lon, lat]
                        },
                        properties: {
                            id: cols[0] || `obs-${i}`,
                            datetime: cols[1] || '',
                            report_date: cols[2] || '',
                            year: year,
                            month: cols[4] || '',
                            hour: cols[5] || '',
                            season: cols[6] || '',
                            country: cols[8] || '',
                            state: cols[9] || '',
                            city: cols[10] || '',
                            shape: cols[13] || '',
                            duration: cols[14] || '',
                            description: cols.slice(15).join(";") || '',
                            country_code: countryNameToCode[cols[8]] || ''
                        }
                    });

                } catch (error) {
                    errors.push(`Ligne ${i + 1}: ${error.message}`);
                    continue;
                }
            }

            return {
                features,
                errors,
                processed
            };
        }

        // Conversion asynchrone par morceaux
        async function convertInChunks(lines, options) {
            const chunkSize = parseInt(document.getElementById('chunkSize').value) || 10000;
            const totalLines = lines.length;
            const features = [];
            const errors = [];
            let processed = 0;
            let chunkCount = 0;

            elements.chunkInfo.textContent = `Taille des morceaux : ${chunkSize.toLocaleString()} lignes`;

            for (let start = 0; start < totalLines; start += chunkSize) {
                if (!isConverting) {
                    throw new Error('Conversion annul√©e');
                }

                chunkCount++;
                const result = processChunk(lines, start, chunkSize, options);

                features.push(...result.features);
                errors.push(...result.errors);
                processed += result.processed;

                // Mettre √† jour la progression
                const percentage = (processed / totalLines) * 100;
                updateProgress(percentage, processed, totalLines);

                // Lib√©rer le thread pour √©viter de bloquer l'interface
                if (chunkCount % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                // Informations sur le morceau en cours
                elements.chunkInfo.textContent =
                    `Morceau ${chunkCount} - ${features.length.toLocaleString()} features extraites`;
            }

            return {
                features,
                errors,
                total: features.length,
                skipped: errors.length
            };
        }

        // D√©marrer la conversion
        async function startConversion() {
            if (isConverting) {
                if (confirm('Une conversion est d√©j√† en cours. Voulez-vous l\'annuler ?')) {
                    isConverting = false;
                    elements.convertBtn.textContent = 'üöÄ D√©marrer la conversion';
                }
                return;
            }

            if (!elements.csvFile.files.length) {
                showError('Veuillez s√©lectionner un fichier CSV');
                return;
            }

            const file = elements.csvFile.files[0];
            const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);

            if (fileSizeMB > 50) {
                if (!confirm(`Le fichier est tr√®s volumineux (${fileSizeMB} MB).\nLa conversion peut prendre plusieurs minutes.\nVoulez-vous continuer ?`)) {
                    return;
                }
            }

            // R√©initialiser l'interface
            hideError();
            elements.result.style.display = 'none';
            elements.preview.style.display = 'none';
            elements.progressContainer.style.display = 'block';
            elements.convertBtn.textContent = '‚èπÔ∏è Annuler la conversion';
            elements.convertBtn.style.background = '#dc3545';
            isConverting = true;

            try {
                // Lire le fichier
                elements.fileInfo.textContent = `Fichier : ${file.name} (${fileSizeMB} MB)`;
                updateProgress(0, 0, 100);

                const reader = new FileReader();

                fileContent = await new Promise((resolve, reject) => {
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Erreur de lecture du fichier'));
                    reader.readAsText(file, 'UTF-8');
                });

                updateProgress(10, 0, 100);

                // Pr√©parer les lignes
                const lines = fileContent.split('\n');
                // Ignorer l'en-t√™te et les lignes vides
                const dataLines = lines.slice(1).filter(line => line.trim());
                totalLines = dataLines.length;

                if (totalLines === 0) {
                    throw new Error('Aucune donn√©e trouv√©e dans le fichier');
                }

                updateProgress(20, 0, totalLines);

                // Options de conversion
                const options = {
                    skipInvalid: document.getElementById('skipInvalid').checked,
                    validateCoords: document.getElementById('validateCoords').checked
                };

                // Conversion par morceaux
                const result = await convertInChunks(dataLines, options);

                if (!isConverting) {
                    elements.convertBtn.textContent = 'üöÄ D√©marrer la conversion';
                    elements.convertBtn.style.background = '#4CAF50';
                    elements.progressContainer.style.display = 'none';
                    return;
                }

                // Cr√©er le GeoJSON final
                currentGeoJSON = {
                    type: "FeatureCollection",
                    features: result.features
                };

                conversionStats = result;

                // Afficher les r√©sultats
                elements.result.style.display = 'block';
                elements.progressContainer.style.display = 'none';
                elements.convertBtn.textContent = 'üöÄ D√©marrer la conversion';
                elements.convertBtn.style.background = '#4CAF50';

                elements.status.innerHTML = `
                    <div class="success">
                        ‚úÖ Conversion termin√©e avec succ√®s !
                    </div>
                `;

                let statsHTML = `
                    <strong>üìä Statistiques d√©taill√©es :</strong><br><br>
                    ‚Ä¢ Lignes totales dans le fichier : <strong>${(lines.length - 1).toLocaleString()}</strong><br>
                    ‚Ä¢ Lignes avec donn√©es : <strong>${totalLines.toLocaleString()}</strong><br>
                    ‚Ä¢ Features GeoJSON g√©n√©r√©es : <strong>${result.total.toLocaleString()}</strong><br>
                    ‚Ä¢ Lignes ignor√©es : <strong>${result.skipped.toLocaleString()}</strong><br>
                    ‚Ä¢ Taux de r√©ussite : <strong>${((result.total / totalLines) * 100).toFixed(1)}%</strong><br>
                    ‚Ä¢ Taille estim√©e du GeoJSON : <strong>${Math.round(JSON.stringify(currentGeoJSON).length / (1024 * 1024) * 10) / 10} MB</strong>
                `;

                if (result.errors.length > 0) {
                    statsHTML += `<br><br><strong>Erreurs principales :</strong><br>`;
                    const topErrors = result.errors.slice(0, 5);
                    topErrors.forEach(error => {
                        statsHTML += `‚Ä¢ ${error}<br>`;
                    });
                    if (result.errors.length > 5) {
                        statsHTML += `‚Ä¢ ... et ${result.errors.length - 5} autres erreurs`;
                    }
                }

                elements.stats.innerHTML = statsHTML;

                // Faire d√©filer vers les r√©sultats
                elements.result.scrollIntoView({
                    behavior: 'smooth'
                });

            } catch (error) {
                showError(`Erreur lors de la conversion : ${error.message}`);
                elements.progressContainer.style.display = 'none';
                elements.convertBtn.textContent = 'üöÄ D√©marrer la conversion';
                elements.convertBtn.style.background = '#4CAF50';
                isConverting = false;
            }
        }

        // T√©l√©charger le GeoJSON
        function downloadGeoJSON() {
            if (!currentGeoJSON) {
                showError('Aucune donn√©e √† t√©l√©charger');
                return;
            }

            try {
                const jsonString = JSON.stringify(currentGeoJSON);
                const blob = new Blob([jsonString], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ufo-sightings.geojson';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                // Feedback
                alert(`‚úÖ Fichier t√©l√©charg√© avec succ√®s !\n\nContient ${conversionStats.total.toLocaleString()} observations.`);

            } catch (error) {
                showError('Erreur lors du t√©l√©chargement : ' + error.message);
            }
        }

        // Afficher un aper√ßu
        function showPreview() {
            if (!currentGeoJSON || !currentGeoJSON.features.length) {
                showError('Aucune donn√©e √† afficher');
                return;
            }

            const previewFeatures = currentGeoJSON.features.slice(0, 10);
            const previewData = {
                type: "FeatureCollection",
                features: previewFeatures
            };

            elements.previewContent.textContent = JSON.stringify(previewData, null, 2);
            elements.preview.style.display = 'block';
            elements.preview.scrollIntoView({
                behavior: 'smooth'
            });
        }

        // R√©initialiser le convertisseur
        function resetConverter() {
            if (isConverting) {
                if (!confirm('Une conversion est en cours. Voulez-vous vraiment r√©initialiser ?')) {
                    return;
                }
                isConverting = false;
            }

            currentGeoJSON = null;
            conversionStats = null;
            fileContent = '';

            elements.csvFile.value = '';
            elements.result.style.display = 'none';
            elements.preview.style.display = 'none';
            elements.progressContainer.style.display = 'none';
            elements.fileInfo.textContent = '';
            elements.convertBtn.textContent = 'üöÄ D√©marrer la conversion';
            elements.convertBtn.style.background = '#4CAF50';
            hideError();
        }

        // Gestionnaire d'√©v√©nements pour le fichier
        elements.csvFile.addEventListener('change', function() {
            if (this.files.length > 0) {
                const file = this.files[0];
                const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);
                elements.fileInfo.textContent = `Fichier s√©lectionn√© : ${file.name} (${fileSizeMB} MB)`;
                hideError();
            }
        });

        // Instructions initiales
        document.addEventListener('DOMContentLoaded', function() {
            elements.fileInfo.textContent = 'Aucun fichier s√©lectionn√©';

            // Astuce pour les grands fichiers
            const chunkSizeInput = document.getElementById('chunkSize');
            chunkSizeInput.addEventListener('change', function() {
                const value = parseInt(this.value);
                if (value < 1000) this.value = 1000;
                if (value > 50000) this.value = 50000;
            });
        });
    </script>
</body>

</html>