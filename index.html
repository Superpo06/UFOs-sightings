<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
    <title>Le Mus√©e des OVNIs</title>

    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        /* Side panel */
        
        #sidepanel {
            position: absolute;
            top: 0;
            left: 0;
            width: 300px;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            z-index: 1000;
            transition: transform 0.3s;
            overflow-y: auto;
        }
        
        #sidepanel.collapsed {
            transform: translateX(-260px);
        }
        
        #togglePanel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: black;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 18px;
            z-index: 1100;
        }
        
        h2 {
            margin-top: 40px;
            font-size: 18px;
        }
        
        label {
            display: block;
            margin-top: 15px;
            font-size: 14px;
        }
        
        select,
        input {
            width: 100%;
        }
        
        #yearValue {
            font-size: 13px;
        }
        
        canvas {
            margin-top: 20px;
        }
    </style>
</head>

<body>

    <!-- Side Panel -->
    <div id="sidepanel" class="collapsed">
        <button id="togglePanel">‚ò∞</button>

        <h2>Observations OVNI</h2>

        <label for="countryFilter">Pays</label>
        <select id="countryFilter">
            <option value="" disabled selected>‚Äî S√©lectionner un pays ‚Äî</option>
            <option value="all">Tous les pays</option>
        </select>

        <label for="shapeFilter">Forme de l'observation</label>
        <select id="shapeFilter">
            <option value="all">Toutes les formes</option>
        </select>


        <label for="yearFilter">Jusqu'√† l'ann√©e</label>
        <input type="range" id="yearFilter" min="1900" max="2025" value="1980">
        <span id="yearValue">2025</span>

        <canvas id="timeChart" height="200"></canvas>
        <button id="toggleTheme" style="width:100%; margin-top:10px;">
    üåô Mode sombre
        </button>

    </div>

    <!-- Map -->
    <div id="map"></div>

    <script>
        "use strict";
        /* Met en surbrillance la fronti√®re du pays au survol */
        function highlightFeature(e) {
            e.target.setStyle({
                weight: 3,
                color: '#FFFF00'
            });
        }

        /* Ajoute des marqueurs pour les observations filtr√©es */
        function addMarkers(map, features) {
            markersLayer.clearLayers();

            for (let f of features) {
                let lat = f.geometry.coordinates[1];
                let lon = f.geometry.coordinates[0];

                let popup = `
                    <b>${f.properties.city}, ${f.properties.state}</b><br>
                    <b>Forme :</b> ${f.properties.shape}<br>
                    <b>Ann√©e :</b> ${f.properties.year}<br>
                    <b>Dur√©e :</b> ${f.properties.duration}<br><br>
                    ${f.properties.description}
                `;

                L.circleMarker([lat, lon], {
                        radius: 4,
                        color: "#00ffcc",
                        weight: 1,
                        fillOpacity: 0.8
                    })
                    .on("click", () => {
                        focusOnEvent(lat, lon, 8);
                    })
                    .bindPopup(popup)
                    .addTo(markersLayer);

            }

            markersLayer.addTo(map);
        }

        function applyFilters() {
            let selectedCountry = countryFilter.value;
            let selectedShape = shapeFilter.value;
            let year = parseInt(yearFilter.value);

            let filtered = allFeatures.filter(f => {
                return (
                    (selectedCountry === "all" || selectedCountry === "" ||
                        f.properties.country_code === selectedCountry) &&
                    (selectedShape === "all" ||
                        f.properties.shape === selectedShape) &&
                    f.properties.year <= year
                );
            });

            addMarkers(map, filtered);
            updateChart(filtered);
        }


        /* Chart */
        function updateChart(features) {
            const canvas = document.getElementById("timeChart");
            const ctx = canvas.getContext("2d");

            // Nettoyage
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Comptage par ann√©e
            let counts = {};
            features.forEach(f => {
                let y = f.properties.year;
                counts[y] = (counts[y] || 0) + 1;
            });

            let years = Object.keys(counts).map(Number).sort((a, b) => a - b);
            if (years.length === 0) return;

            let values = years.map(y => counts[y]);

            const padding = 30;
            const w = canvas.width - padding * 2;
            const h = canvas.height - padding * 2;

            const maxValue = Math.max(...values);

            // Axes
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + h);
            ctx.lineTo(padding + w, padding + h);
            ctx.stroke();

            // Courbe
            ctx.strokeStyle = "#00ffcc";
            ctx.lineWidth = 2;
            ctx.beginPath();

            years.forEach((year, i) => {
                const x = padding + (i / (years.length - 1)) * w;
                const y = padding + h - (values[i] / maxValue) * h;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });

            ctx.stroke();

            // Points
            ctx.fillStyle = "#00ffcc";
            years.forEach((year, i) => {
                const x = padding + (i / (years.length - 1)) * w;
                const y = padding + h - (values[i] / maxValue) * h;

                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }


        function addCountriesBorders(map, countriesGeoJSON) {

            let countriesLayer = L.geoJSON(countriesGeoJSON, {
                style: {
                    color: "#00FF00",
                    weight: 2,
                    fillOpacity: 0
                },
                onEachFeature: function(feature, layer) {

                    layer.on({
                        mouseover: highlightFeature,
                        mouseout: e => countriesLayer.resetStyle(e.target),

                        click: function() {
                            const code = feature.properties.cca2.toUpperCase();
                            if (!code) return;

                            console.log("Pays cliqu√© :", code);

                            countryFilter.value = code;
                            applyFilters();
                        }

                    });

                    if (feature.properties && feature.properties.name) {
                        layer.bindPopup(feature.properties.name.common);
                    }
                }
            }).addTo(map);
        }

        async function load_data() {
            const response = await fetch("data/ufo-sightings-with-codes-v2.geojson");
            const geojson = await response.json();
            return geojson.features;
        }

        function focusOnEvent(lat, lon, zoom = 8) {
            map.flyTo([lat, lon], zoom, {
                animate: true,
                duration: 1
            });
        }

        /* Init */
        let map;
        let allFeatures = [];
        let markersLayer = L.layerGroup();
        let chart;
        let countriesSet = new Set();
        let shapesSet = new Set();
        let lightmode = "dark";


        function createDistinctCountries(features) {
            features.forEach(f => {
                countriesSet.add(f.properties.country);
            });
            return Array.from(countriesSet).sort();
        }

        let tileLayer;

        function loadBaseMap() {
            if (tileLayer) {
                map.removeLayer(tileLayer);
            }

            if (lightmode === "light") {
                tileLayer = L.tileLayer(
                    'https://tiles.stadiamaps.com/tiles/stamen_toner/{z}/{x}/{y}{r}.png', {
                        maxZoom: 20
                    }
                );
            } else {
                tileLayer = L.tileLayer(
                    'https://tiles.stadiamaps.com/tiles/stamen_toner_dark/{z}/{x}/{y}{r}.png', {
                        maxZoom: 20
                    }
                );
            }

            tileLayer.addTo(map);
        }


        window.onload = async() => {
            map = L.map('map', {
                center: [20, 0],
                zoom: 3,
                minZoom: 2
            });
            loadBaseMap();
            /* Cr√©ee les feature et ajoute le mapping */
            allFeatures = await load_data();

            let countries = [...new Set(allFeatures.map(f => f.properties.country_code))].sort();

            //populate country filter
            countries.forEach(s => {
                let opt = document.createElement("option");
                opt.value = s;
                opt.textContent = s;
                countryFilter.appendChild(opt);
            });


            // Populate shape filter
            allFeatures.forEach(f => {
                if (f.properties.shape) {
                    shapesSet.add(f.properties.shape);
                }
            });

            [...shapesSet].sort().forEach(shape => {
                let opt = document.createElement("option");
                opt.value = shape;
                opt.textContent = shape;
                shapeFilter.appendChild(opt);
            });


            addMarkers(map, allFeatures);
            updateChart(allFeatures);

            let responseCountries = await fetch("data/countries.json");
            let countriesText = await responseCountries.text();
            let countriesGeoJSON = JSON.parse(countriesText);


            addCountriesBorders(map, countriesGeoJSON);

            countryFilter.onchange = applyFilters;
            shapeFilter.onchange = applyFilters;

            yearFilter.oninput = () => {
                yearValue.textContent = yearFilter.value;
                applyFilters();
            };

            togglePanel.onclick = () => {
                sidepanel.classList.toggle("collapsed");
                togglePanel.textContent =
                    sidepanel.classList.contains("collapsed") ? "‚ò∞" : "‚úï";
            };

            toggleTheme.onclick = () => {
                lightmode = (lightmode === "dark") ? "light" : "dark";
                toggleTheme.textContent =
                    lightmode === "dark" ? "üåô Mode sombre" : "‚òÄÔ∏è Mode clair";
                loadBaseMap();
            };


            createDistinctCountries(allFeatures);
            console.log("Distinct countries:", countriesSet);
            applyFilters();

        };
    </script>

</body>

</html>